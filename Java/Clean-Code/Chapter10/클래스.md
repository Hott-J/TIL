# 클래스



## 캡슐화되어야 한다

**캡슐화**

- 객체의 실제 구현을 외부로부터 감추는 방식
- 외부의 잘못된 사용을 방지한다
- 경계에서 나왔던 Map<Sensor> 참고 



## 단일 책임 원칙

**클래스가 맡은 책임이 한 개인가**

- 함수와 마찬가지로 클래스도 작아야 한다
- 함수는 라인 수로 크기를 측정했는데, 클래스는 맡은 **책임**의 수로 크기를 측정한다
- 클래스 설명은 만일(if), 그리고(and), 하며(or), 하지만(but)을 사용하지 않고 25단어 내외로 가능해야 한다
  - 책임이 한가지여야 한다

- SPR 해야한다. 자잘한 단일 클래스가 많아지면 큰 그림을 이해하기 어렵다고 우려한다. 하지만 작은 클래스가 많은 시스템이든 큰 클래스가 몇 개 뿐인 시스템이든 돌아가는 부품은 그 수가 비슷하다
- "도구상자를 어떻게 관리하고 싶은가?" 작은 서랍을 많이 두고 기능과 이름이 명확한 컴포넌트를 나눠 넣고 싶은가? 아니면 큰 서랍을 몇개를 두고 모두를 던져 넣고 싶은가?"
- 큼직한 다목적 클래스 몇 개로 이뤄진 시스템은 (변경을 가할 때) 당장 알 필요가 없는 사실까지 들이밀어 독자를 방해한다
- 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다



## 낮은 결합도, 높은 응집도

**결합도**

- 다른 모듈간의 의존도



**응집도**

- 모듈 내부의 기능 집중도



*결합도는 낮을 수록 응집도는 높을 수록 유지보수성이 좋다*



- 문제점
  - 결합도가 높은 클래스의 문제점
    - 연관된 클래스가 변경되면 수정이 필요하다
    - 결합도가 높으면 연관된 클래스들을 모두 이해해야 한다
  - 응집도가 낮은 클래스의 문제점
    - 여러 기능이 있으므로 이해하기 어렵다
    - 재사용하기 어렵다



**결합도는 낮아야 한다**

- 시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다
- DIP
  - 클래스가 상세한 구현이 아니라 추상화에 의존해야한다
  - 추상화를 이용하면 테스트 코드 짜기에 용이
    - 객체를 Mockking하면 변경되는 클래스도 테스트할 수 있다
    - **확장될 가능성이 적다면 일단은 결합하고, 나중에 추상화해도 좋다**



**응집도는 높아야 한다**

- 클래스는 인스턴스 변수 수가 적어야 한다. 메서드는 인스턴스 변수를 하나 이상 사용해야 한다. 메서드가 인스턴스 변수를 많이 사용할수록 응집도가 높다
- 응집도가 높다
  - 클래스에 속한 메서드와 변수가 서로 의존하며 논리적인 단위로 묶인다 = 서로 관계있는 애들만 모여있다
- 클래스가 응집도를 잃어간다면 함수를 쪼개야한다



## 변경하기 쉬워야 한다

 ![image](https://user-images.githubusercontent.com/47052106/163920133-6215a235-7817-4038-9464-b3f26ab1be1a.png)

![image](https://user-images.githubusercontent.com/47052106/163920172-056d6c4a-f286-4402-b9e0-aaf5eb28e541.png)

