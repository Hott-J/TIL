# C++

## C와 C++
* C: `절차지향`, 같은 이름을 가진 함수 존재 불가, 변수와 함수를 초기에 작성
* C++: `객체지향`, 같은 이름을 가진 함수 존재 가능(오버로딩, 오버라이딩), 변수와 함수를 어디서나 선언 가능

## 스크립트 언어 vs 컴파일 언어
* 스크립트 언어: 컴파일러 없음, 실행시 바로 해석되어 코드 변경시 실행할 때마다 결과 바뀜
* 컴파일 언어: 컴파일러 있음, 컴파일러를 통해 컴파일되어 코드 수정 후 재 컴파일 전까지는 결과 같음

## malloc() vs new
* malloc(): 함수, 시스템 함수로 함수 안에서 메모리 할당
* new: 연산자, 생성자를 호출하여 메모리 할당, 생성시 초기화 가능
  * 생성시 초기화: constructor(): a(1), b(2) {}
  * 생성 후 초기화: constructor() { a=1; b=2; }
* 추가
  * realloc(): 메모리 할당에 실패할 경우 null 반환 -> 기존의 메모리가 할당되어 있는 포인터를 잃음 -> 메모리 누수 발생 가능 / 기존의 메모리  주소를 저장하고 실패시 복구하는 작업 필요
  * calloc(size_t n, size_t size): 매개변수 2개, 할당 메모리를 모두 0으로 초기화 / (char*) calloc(10, sizeof(char))
  * malloc(size_t size): 매개변수 1개, 할당 메모리에는 쓰레기 값이 있음 / (char*) malloc(sizeof(char)*10)

## 해시 테이블 vs STL map

## 얕은 복사 vs 깊은 복사
* 얕은 복사: 주소값을 공유, `디폴트 복사 생성자`
* 깊은 복사: 새로운 메모리를 동적으로 할당받고 원본 데이터도 복사

## static
  * static 전역변수: 파일 내에서만 참조 허용
  * 함수 안의 static: 한번 초기화, 함수가 끝나도 소멸X
  * 클래스의 static 멤버변수: 메모리 공간에 딱 1개만 할당되어 공유, 객체 안이 아니라 외부에 있는 변수
  * 클래스의 static 멤버함수: 객체의 외부에 존재, 객체 생성 전에도 호출 가능해 static 변수만 접근 가능

## virtual
* 가상 소멸자: 상속에서 부모 클래스의 포인터로 자식 클래스를 호출할 때(`다형성`), 가상 함수로 정의되지 않은 자식 클래스의 오버라이딩된 함수를 호출하면 부모 클래스의 멤버 함수가 호출됨 -> 자식 클래스의 소멸자가 가상 함수로 정의되지 않으면 부모 클래스의 소멸자가 호출, 자식 클래스의 소멸자는 호출 되지 않음
* 가상 함수: 실제 객체의 자료형을 기준으로 하는게 아닌, 포인터 변수의 자료형을 기준으로 판단 -> 객체의 자료형에 따라 멤버 함수가 호출
  * 가상 함수 테이블: 가장 마지막에 오버라이딩한 자식 클래스의 멤버함수가 테이블에 포함
  * key, value key: 호출하고자 하는 함수 / value: 주소 정보
* 순수 가상 함수: 함수의 선언만 있고 정의는 없음, 자식 클래스에서 반드시 재정의 필요, 뒷부분에 `=0`을 덧붙임, 순수 가상 함수를 포함하는 클래스는 `추상 클래스`

## 가상 테이블

## volatile
* 외부 요인으로 해당 값이 언제든지 바뀔 수 있음을 의미함, 해당 변수에서는 최적화X
* 컴파일러가 최적화하는 과정에서 원하지 않는 최적화를 방지하고자 하는 키워드

## 포인터의 개념
* 메모리 주소를 저장하는 변수, 주소를 지칭하는 것
* 엘리베이터에서 포인터는 해당 층을 표시하는 버튼, 10층 버튼을 누르면 10층으로 이동하듯이 해당 위치를 기리키는 변수

## 스마트 포인터
* 가비지 콜렉션이 없는 C++에서 안전하게 메모리를 해제하는 방법, 메모리 누수로부터 프로그램의 안정성 보장, 사용이 끝난 메모리를 자동으로 해제(delete를 따로 사용할 필요X)
* 종류
  * unique_ptr: 하나의 스마트 포인터만이 특정 객체 소유, 소유권 이전 가능(move() 함수), 복사 불가
  * shared_ptr: 하나의 특정 객체를 참조하는 스마트 포인터가 총 몇 개인지 참조, 참조 개수가 0이되면 메모리 자동 해제
  * weak_ptr: 하나 이상의 shared_ptr이 소유하는 객체에 대한 접근 제공, 소유자의 수에는 포함X -> 서로를 참조하는 shared_ptr은 영원히 메모리가 해제되지 않음, weak_ptr은 이러한 순환 참조 제거에 사용

## 제네릭 프로그래밍
* templete 키워드로 선언
* 제너릭 함수: 동일 코드에 다양한 데이터 타입을 적용할 수 있게 일반화된 함수

## 변수와 메모리
* 데이터 영역: `전역변수`와 `static변수`가 할당, 프로그램의 시작과 동시에 할당, 프로그램 종료시 소멸
* 스택 영역: 함수 호출시 생성되는 `지역변수`와 `매개변수` 할당, 함수 종료시 소멸
* 힙 영역: 동적인 메모리 할당

## 클래스 vs 구조체
* 클래스: 변수, 함수, 메소드를 포함 / 접근제어 지시자가 없으면 private
* 구조체: 변수의 집합 / 접근제어 지시자가 없으면 public