# Etc 

<br>

## 컴파일 언어와 스크립트 언어의 차이
  * `컴파일 언어`는 컴파일러를 통해 사전에 컴파일 되어 기계어 상태로 실행되고 `스크립트 언어`는 컴파일 단계 없이 인터프리터에 의해 실행 단계해서 한 줄씩 기계어로 번역하여 실행
  * 일반적으로 컴파일 언어가 스크립트 언어에 비해 빠르고 안정적임

## 동기식과 비동기식의 차이
  * 동기식은 요청에 대한 응답을 기다린 후 `응답이 오면 실행`하는 방식이고 비동기식은 요청에 대한 `응답을 기다리지 않고 실행`하는 방식
  * 동기식은 구성이 단순하나 멀티태스킹이 불가능하고 비동기식은 멀티태스킹이 가능하나 요청량이 많아질 경우 부하 컨트롤과 데이터의 일관성 유지 등 추가적인 처리가 필요
  * 동기는 호출한 함수가 작업 완료를 신경쓰고, 비동기는 호출된 함수가 작업 완료를 신경씀

## 블락킹과 논블락킹의 차이
  * 블락킹은 주로 I/0 처리 함수가 끝날 때까지 기다리고 처리가 끝나면 결과를 리턴하는 방식이고 논블락킹은 I/0 처리 함수가 끝나지 않더라도 기다리지 않고 다른 작업을 처리하는 방식
  * 블락킹은 요청한 작업을 마칠 때까지 계속 기다리고, 논블락킹은 요청한 작업을 즉시 마칠 수 없다면 즉시 리턴함

## 블락킹/논블락킹과 동기/비동기의 차이
  * 블락킹/논블락킹
    * 호출되는 함수가 `바로 return하느냐 마느냐가` 관심사이다.
  * 동기/비동기
    * 호출되는 함수의 `작업 완료 여부를 누가 신경쓰느냐가` 관심사이다.
    * 비동기는 `콜백`으로 호출된 함수가 완료 여부를 신경쓰고 호출한 함수는 그냥 자기일을 하다가 콜백을 받으면 됨
  * [참고](https://velog.io/@wonhee010/%EB%8F%99%EA%B8%B0vs%EB%B9%84%EB%8F%99%EA%B8%B0-feat.-blocking-vs-non-blocking)

* 포인터
  * 메모리 상의 주소를 저장하는 공간

* Call by value vs Call by reference

* 얕은 복사 vs 깊은 복사
  * 단순 객체 복사
    ```python
    # mutable 객체 (변경가능 객체(리스트 등))
    a = [1, 2, 3, 4]
    b = a     # copy
    print(b)    # [1, 2, 3, 4]
    b[2] = 100   # b의 item 변경
    print(b)    # [1, 2, 100, 4]
    print(a)    # [1, 2, 100, 4], a의 item도 수정됨!!
    
    # immutable 객체
    a = 10
    b = a
    print(b)    # 10 출력력
    b = "abc"
    print(b)    # abc 출력
    print(a)    # 10 출력
    ```
  * 얕은 복사
    * 객체를 복사할 때, 해당 객체만 복사하여 새 객체를 생성한다.
    * 복사된 객체의 인스턴스 변수는 원본 객체의 인스턴스 변수와 같은 메모리 주소를 참조한다.
    * 따라서, 해당 메모리 주소의 값이 변경되면 원본 객체 및 복사 객체의 인스턴스 변수 값은 같이 변경된다.
    ```python
    import copy
    # immutable
    a = [1, [1, 2, 3]]
    b = copy.copy(a)    # shallow copy 발생
    print(b)    # [1, [1, 2, 3]] 출력
    b[0] = 100  # 숫자
    print(b)    # [100, [1, 2, 3]] 출력,
    print(a)    # [1, [1, 2, 3]] 출력, shallow copy 가 발생해 복사된 리스트는 별도의 객체이므로 item을 수정하면 복사본만 수정된다. (immutable 객체의 경우)

    # mutable
    c = copy.copy(a)
    c[1].append(4)    # 리스트의 두번째 item(내부리스트)에 4를 추가 c[1]=[1,2,3,4] : list (mutable)
    print(c)    # [1, [1, 2, 3, 4]] 출력
    print(a)    # [1, [1, 2, 3, 4]] 출력, a가 c와 똑같이 수정된 이유는 리스트의 item 내부의 객체는 동일한 객체이므로 mutable한 리스트를 수정할때는 둘다 값이 변경됨
    ```
  * 깊은 복사
    * 복사본의 값이 mutable한 객체일때, 이를 변경했을 시, 원본의 값도 변경되는 현상을 해결
    * 객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식.
    * 전부를 복사하여 새 주소에 담기 때문에 참조를 공유하지 않는다.
    ```python
    import copy
    a = [1, [1, 2, 3]]
    b = copy.deepcopy(a)    # deep copy 실행 
    print(b)    # [1, [1, 2, 3]] 출력
    b[0] = 100 # immutable
    b[1].append(4) # mutable
    print(b)    # [100, [1, 2, 3, 4]] 출력
    print(a)    # [1, [1, 2, 3]] 출력
    ```

## TDD
* `테스트 코드를 작성 한 후 그것을 통과하는 실행 코드를 작성`하는 cycle로 개발을 해가는 방법으로 디버깅이 쉬워지고 코드의 신뢰성이 높아짐

## 크롬 탭은 프로세스인지 스레드인지
* 크롬은 탭마다 PID를 가지고 있는 Process이며 각 Tab마다 랜더링 정보나 기타 데이터를 따로 관리, 그로 인해 메모리를 많이 잡아먹기도 하지만 하나의 Tab에 오류가 생겼다고 모든 Tab에 영향을 끼치진 않는 장점이 존재

## 함수형 프로그래밍
* 함수형 프로그래밍은 계산을 수학적 함수의 조합으로 생각하는 방식
* 1급 객체와 데이터 불변성 그리고 고차함수, 합성함수, 순수함수와 같은 다양한 함수 개념으로 구성

## Git에서 merge와 rebase의 차이
* git merge를 하면 브랜치를 브랜치의 커밋 로그는 사라지고 `병합하는 커밋 로그가 master에 head에 추가`
* git rebase를 하면 브랜치를 base로 master를 `커밋을 재정렬하여 브랜치의 커밋 하나 하나가 master에 정리되어 추가`

* 도커와 가상 머신의 차이
  * 

* 쿠버네티스 및 가상 플랫폼이 핫해진 이유
  * 

* 클라우드로의 전환이 필수적인 이유
  * 비용이 낮음: 서버 장비를 구매하고 유지하는 비용이 장기적으로 봤을 때 클라우드 시스템을 이용하는 비용보다 비쌈
  * 효율적인 인적자원 운영: 직접 방문해야하는 On-premise에 반해 웹에서 100% 제어 및 모니터링이 가능하기 때문에 개발(혹은 설계) 인력과 공존이 가능
  * 안정성: 클라우드는 다양한 공간으로 분산하기 때문에, 분선돤 모든 곳에 동시다발적으로 문제가 생기지 않는한 장애가 발생하지 않음
  * 확장성: 트래픽이 임계점에 도달하면 빠르게 서버를 확장할 수 있음

* HDFS
  * 
* 하둡 에코 시스템
  * 
* 주키퍼의 지노드에 저장되는 데이터
  * 
* Hot Warm 아키텍처
  *
* Spark의 RDD
  *
* nginx 설정에서 성능을 높이는 방법
  * 
* 적정 샤드의 개수를 정하는 방법
  * 
* ElasticSearch에서 마스터가 하는 역할
  * 
* 카프카
  * 
* flume과 logstash의 역할
  * 
* 리눅스의 파일 권한
  * 

* 프레임워크와 플랫폼의 차이

* Jquery 사용 이유

*  DES128/256 차이

*  HTML5와 HTML 차이

* 검색엔진

* OAuth

* CORS란?

* CORS 해결방법

* JSON, XML의 차이
  * JSON 종료 태그를 사용하지 않음, 데이터를 더 빨리 읽고 쓸수 있음