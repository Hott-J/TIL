# Database

<br>

## Table of Contents
* [DBMS](#dbms)
* [DB를 사용하는 이유](#db를-사용하는-이유)
* [테이블](#테이블)
* [행](#행)
* [열](#열)
* [도메인](#도메인)
* [뷰](#뷰)
* [스키마와 테이블의 차이](#스키마와-테이블의-차이)
* [키](#키)
* [트랜잭션](#트랜잭션)
* [ACID](#acid)
* [트랜잭션 격리수준](#트랜잭션-격리수준)
* [Commit과 Rollback](#commit과-rollback)
* [동시성 제어 (병행 제어)](#동시성-제어-병행-제어)
* [무결성 제약조건](#무결성-제약조건)
* [조인](#조인)
* [시퀀스(오라클)](#시퀀스오라클)
* [트리거](#트리거)
* [SQL](#sql)
* [SQL Injection](#sql-injection)
* [힌트(Hint)](#힌트hint)
* [인덱스(Index)](#인덱스index)
* [정규화](#정규화)
* [DB 클러스터링과 리플리케이션의 차이](#db-클러스터링과-리플리케이션의-차이)
* [커넥션 풀](#커넥션-풀)
* [관계형 데이터베이스(SQL)와 비관계형 데이터베이스(NoSQL)의 차이](#관계형-데이터베이스sql와-비관계형-데이터베이스nosql의-차이)
* [Redis와 MongoDB](#redis와-mongodb)
* [Redis의 데이터 휘발을 막기 위한 방법](#redis의-데이터-휘발을-막기-위한-방법)
* [PostgresSQL과 ElasticSearch의 차이점](#postgressql과-elasticsearch의-차이점)
* [[추가] NoSQL(Not Only SQL)](#추가-nosqlnot-only-sql)
* [파티셔닝](#파티셔닝)
* [샤딩](#샤딩)
* [레플리카](#레플리카)

<br>

## DBMS

* 데이터베이스 관리 시스템(DataBase Management System)
* 여러 사용자가 데이터베이스에 접근하여 사용할 수 있도록 해주는 SW
* 정의, 조작, 제어 기능 수행

|기능|설명|
|:--:|--|
|정의|DB 구조 정의(테이블, 속성)|
|조작|DB 연산 처리(수정, 삭제, 검색)|
|제어|데이터 무결성 및 일관성 유지, 접근 권한 부여, 동시성 제어|

<br>

## DB를 사용하는 이유

* `파일 시스템의 문제점을 해결`하기 위해 사용
* 파일 시스템이 OS마다 다를 수 있기 때문에 OS에 종속적인 파일 시스템을 이용하는 것은 프로그램의 확장성을 해침
* 데이터 중복, 비일관성, 검색 등의 문제 존재 -> 중복 최소화, 보안성, 계속적 변화에 대한 적응
* DB는 `원자적 갱신`, `동시성 제어`, `데이터 보호`, `백업 및 회복` 등의 여러 데이터 관리 기능을 통해 데이터를 편하게 관리할 수 있음

<br>

## 테이블

* 행과 열로 이루어진 데이터의 집합

<br>

## 행

* 테이블을 구성하는 데이터 셋으로 `튜플`이나 `레코드`라고 불림
* 한 객체에 대한 정보를 가짐

<br>

## 열

* 테이블을 구성하는 데이터 셋으로 `속성`이라고 불림

<br>

## 도메인

* 데이터베이스 필드에 채워질 수 있는 `값들의 집합`

<br>

## 뷰

* 하나 이상의 테이블에서 유도된, 메모리에 물리적으로 존재하지 않는 `가상 테이블`
* 특정 사용자로부터 특정 속성을 `숨기는` 기능으로 뷰를 정의하여 그 뷰를 테이블처럼 사용
* 인덱스를 가질 수 없고, 뷰의 정의를 변경할 수 없음
* 테이블의 기본키를 포함하여 정의 시, 삽입/삭제/갱신 가능

<br>

## 스키마와 테이블의 차이
### 👉 스키마
* 데이터베이스의 조직, 데이터 구조에 대한 공식적인 설명 -> 테이블, 열, 데이터 유형, 인덱스 등의 정의를 포함
* `테이블(릴레이션)의 이름과 속성들의 나열`로 테이블에서의 첫 행 헤더, 데이터의 구조와 구성을 설명
### 👉 테이블
* `행과 열로 구성된 데이터 집합`

<br>

## 키

![image](https://user-images.githubusercontent.com/38900338/139516864-ce72fa77-10dc-465c-9e6d-959db391f61d.png)

* 검색, 정렬 시 튜플을 구분하는 기준이 되는 속성 (Attribute)
* 용어
  * 유일성: 키로 튜플을 유일하게 식별할 수 있음
  * 최소성: 튜플을 구분하는데 꼭 필요한 속성들로만 구성

### 👉 후보 키

* 릴레이션을 구성하는 속성들 중에서 튜플을 `유일하게 식별`할 수 있는 속성들의 `부분 집합`
  * 기본 키로 사용할 수 있는 속성들
* 모든 테이블은 하나 이상의 후보 키를 가짐
* 유일성과 최소성 만족

### 👉 기본 키

* 후보 키 중에서 선택한 Main Key (주 키)
* 특정 튜플을 유일하게 식별할 수 있음
* 중복 값과 NULL 값 불가 (`개체 무결성`)
* 유일성과 최소성 만족

### 👉 대체 키 (보조 키)

* 후보 키가 두개 이상일 때, 기본 키를 제외한 나머지 후보 키

### 👉 슈퍼 키

* 유일성을 만족, 최소성은 만족하지 않는 속성들의 집합

### 👉 외래 키

* 한 테이블의 키 중에서 다른 테이블의 튜플을 식별할 수 있는 키
* 참조되는 릴레이션의 `기본 키`와 대응되어 릴레이션 간에 `참조 관계`를 표현하는 키
* 사용 이유: 테이블을 연결, 중복 방지, 무결성 유지
  * 예시: 물건 구매시 같은 사람이 여러 물건을 구매하면 사람에 대한 데이터가 중복 -> 사람과 물건 구매로 테이블을 분리해 중복 제거

<br>

## 트랜잭션

* 데이터베이스의 상태를 변화시키는 하나의 `원자적인/논리적인 작업 단위`
* Lock과 유사한 기능을 하지만 Lock은 동일한 자원을 요청할 경우 한 시점에는 하나의 커넥션만 변경하는데에 반해 트랜잭션은 논리적인 작업의 쿼리의 개수와 관계없이 논리적인 작업 셋 자체가 `100% 적용되거나 아무것도 적용되지 않아야 함을 보장`
* 주의사항
  * 최소한의 코드에 적용하는 것이 좋음
  * DB 커넥션의 수는 제한적 -> 커넥션이 부족해 대기할 수 있음 

<br>

## ACID

* 데이터의 유효성을 보장하기 위한 트랜잭션의 특징
* `Atomicity(원자성)`: `모든 작업이 반영되거나 모두 롤백되는 특성`입니다.
* `Consistency(일관성)`: 데이터는 `미리 정의된 규칙에서만 수정이 가능한 특성`을 의미합니다.
  * 도메인, 외래키 관게 유지
* `Isolation(고립성)`: 두 개 이상의 트랜잭션이 동시에 발생할 때, 서로의 연산에 영향을 줄 수 없음
  * Lock으로 보장
* `Durability(영구성)`: 한번 반영(커밋)된 트랜젝션의 내용은 `영원히 적용`되는 특성을 의미합니다.

<br>

## 트랜잭션 격리수준
* 동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경/조회하는 데이터에 대한 접근 권한 수준을 결정하는 것
* 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준

### 👉 필요성
* 락으로 모든 트랜잭션이 순서대로 처리하도록 하면 DB의 성능이 떨어짐

### 👉 종류
#### Read Uncommitted (레벨 0)
* Select를 수행할 때 해당 데이터에 Shared Lock이 걸리지 않는 레벨
* 다른 트랜잭션에서 커밋되지 않은 내용도 접근할 수 있음
* 일관성 유지가 거의 불가능
#### Read Committed (레벨 1)
* SELECT를 수행하는 동안 해당 데이터에 Shared Lock이 걸리는 레벨
* 커밋된 내용만 접근 가능
#### Repeatable Read (레벨 2)
* 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 레벨
* 트랜잭션에 진입하기 이전에 커밋된 내용만 접근 가능
* 데이터 추가는 허용, 변경/삭제는 허용하지 않음
#### Serializable (레벨 3)
* 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 레벨
* 완벽한 읽기 일관성을 제공함
* 데이터의 추가/변경/삭제 불가능

<br>

## Commit과 Rollback

### 👉 Commit
* 트랜잭션이 성공하여 트랜잭션 결과를 `영구적으로 반영`하는 연산

### 👉 Rollback
* 트랜잭션의 실행을 취소하였음을 알리는 연산
* 트랜잭션이 수행한 결과를 `원래의 상태로 원상 복귀시키는 연산`

<br>

## 동시성 제어 (병행 제어)

### 👉 정의
* 동시에 여러개의 트랜잭션을 병행 수행할 때, 트랜잭션들이 DB의 `일관성`을 파괴하지 않도록 `트랜잭션 간의 상호작용을 제어`하는 것

### 👉 목적
* DB의 공유도 최대화
* 시스템 활용도 최대화
* 응답 시간 최소화
* 단위 시간당 트랜잭션 처리 건수 최대화
* DB의 일관성 유지

### 👉 필요성
#### 갱신 분실
* 같은 데이터를 동시에 갱신할 때 갱신 결과의 일부가 사라짐
#### 모순성
* 동시에 같은 데이터를 갱신할 때, 데이터의 상호 불일치가 발생 (비일관성)
#### 연쇄 복귀
* 트랜잭션 중 하나에 문제가 생겨 롤백되는 경우, 다른 트랜잭션들도 함께 롤백

### 👉 방법1: 로킹(Locking)
* 트랜잭션이 데이터에 접근하기 전에 Lock을 요청해서 Lock이 허락되면 그 로킹 단위에 접근할 수 있도록 하는 기법
* 하나의 트랜잭션이 사용하는 데이터에 다른 트랜잭션이 접근하지 못하게 락을 설정 -> `잠근후 실행, 실행 완료 후 언락`
* 테이블, 속성, 튜플 단위로 락 설정 가능
* 종류
  * 공유락(Shared Lock): 사용중인 데이터를 다른 트랜잭션이 읽기 허용, 쓰기 불허용
  * 베타락(Exclusive Lock): 사용중인 데이터를 다른 트랜잭션이 읽기, 쓰기 모두 불허용

### 👉 교착상태 (데드락)
* 둘 이상의 트랜잭션이 자원의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하며 `무한정 대기`하는 것
* 잠금을 사용하면 발생할 수 있음

### 👉 방법2: 타임스탬프
* `각 트랜잭션이 데이터에 접근할 시간을 미리 지정`해 시간의 순서에 따라 순서대로 데이터에 접근하여 수행
* 제한적인 시간이 존재하므로 데드락 발생하지 않음

<br>

## 무결성 제약조건
* 개체 무결성: 주키는 null, 중복 값을 가질 수 없음
* 참조 무결성: 외래키는 null이거나 참조 릴레이션의 기본키 값과 동일해야 함

<br>

## 조인

* 두 개 이상의 테이블이나 데이터베이스를 `연결하여 데이터를 검색`하는 방법
* 적어도 하나의 칼럼을 서로 공유하고 있어야 함

<br>

## 시퀀스(오라클)

* `순차적으로 증가하는 숫자를 생성`하는 객체
* `기본 키`와 같은 유일한 숫자를 자동으로 생성하는 것
* 캐쉬에 있어 속도 빠름, 중복 방지에 사용

<br>

## 트리거

* DML이 수행되었을 때, 자동으로 실행되게 정의한 프로시저
* DML(INSERT, UPDATE, DELETE)에 의한 데이터 상태관리 자동화
* 데이터 무결성 강화, 업무 처리 자동화

<br>

## SQL

* DML: 데이터를 조작
  |명령어|설명|
  |:---:|:---|
  |SELECT|DB의 데이터 조회 및 검색|
  |INSERT|데이터 삽입|
  |UPDATE|데이터 수정|
  |DELETE|데이터 삭제|

* DDL: 데이터(구조, 객체)를 정의
  |명령어|설명|
  |:---:|:---|
  |CREATE|DB의 테이블 생성|
  |DROP|테이블 삭제|
  |TRUNCATE|테이블의 데이터 삭제, 테이블 초기화|
  |ALTER|테이블 수정|
  * DROP과 TRUNCATE의 차이

* DCL: 권한 제어
  |명령어|설명|
  |:---:|:---|
  |GRANT|객체에 대한 권한 부여|
  |REVOKE|객체에 대한 권한 회수|
  
* TCL: 트랜잭션 설정  
  |명령어|설명|
  |:---:|:---|
  |COMMIT|트랜잭션의 결과 반영|
  |ROLLBACK|트랜잭션 취소 및 원상 복구|

<br>

## SQL Injection

* 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적인 명령을 실행시키는 공격 기법
* view를 활용하여 접근하는 에러를 볼 수 없게 하고 검증 로직을 추가하여 방어해야함
* 입력값 검증, Prepared Statement 사용(쿼리에 대한 컴파일을 먼저 수행하고, 입력값을 나중에 넣는 방식)

<br>

## 힌트(Hint)

* SQL을 `튜닝`하기 위한 지시 구문, 개발자가 직접 최적의 실행 계획을 제공하는 것

<br>

## 인덱스(Index)

### 👉 정의 및 사용 이유
* `추가적인 쓰기와 저장 공간` 사용을 통해 데이터베이스의 `검색 속도 향상`을 위해 사용하는 자료구조
* 칼럼의 값(Key)과 해당 레코드가 저장된 주소를 `키와 값의 쌍`으로 인덱스 정의

### 👉 장단점
* 검색 속도 향상
* 데이터의 추가, 삭제, 수정의 경우 인덱스도 변경해야 하여 성능이 오히려 저하될 수 있음
* 추가적인 저장 공간 필요 및 저장 성능 저하

### 👉 자료구조

#### B 트리

![tree](https://user-images.githubusercontent.com/38900338/105454677-9bf88400-5cc5-11eb-993e-fb6f7b9675a1.png)
* 이진 트리를 확장해서, 더 많은 수의 자식을 가질 수 있게 일반화 시킨 자료구조
* 균형 트리: 루트 ~ 리프의 거리가 일정한 트리
* Branch 노드: Key와 Data 저장

#### B+ 트리

![Bplustree](https://user-images.githubusercontent.com/38900338/105454222-d9104680-5cc4-11eb-96e9-31e46c0bf2aa.png)

* B 트리를 확장해서, 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드(not Leaf)를 추가한 자료구조
* Branch 노드: Key만 저장, Leaf 노드: Key와 Data 저장 + Linked List로 연결(부등호를 사용한 순차 검색에 유용)
* B 트리보다 풀 스캔 빠름
* Leaf 노드를 제외하면 데이터를 저장하지 않아 더 많은 Key를 저장할 수 있음 -> 트리의 높이가 낮아져 Cache Hit 향상 가능

#### 해시 테이블
* 칼럼의 값으로 생성된 해시를 기반으로 인덱스 구현
* O(1)로 매우 빠름
* `인덱싱에선 부등호 연산 때문에 해시 테이블을 사용하면 성능이 떨어짐`
* `>=, Between, like, order by` 등은 불가능하지만 `==, in, is null` 등에서의 성능은 좋음

### 👉 Clustered Index vs Non Clustered Index

#### Clustered Index
* 인덱스로 지정한 컬럼을 기준으로 데이터를 `물리적으로 정렬`하여 사용하는 인덱스
* 테이블 구조에 영향을 미치는 인덱스
* 한 테이블에 `1개` 생성 가능
* `검색 속도는 빠르지만`, 데이터의 입력/수정/삭제는 느림

#### Non-Clustered Index
* 데이터의 위치를 알려주는 인덱스 페이지를 인덱스 컬럼 값을 기준으로 정렬하여 이용하는 인덱스
  * 리프 페이지에서 `컬럼 값 + 데이터의 포인터(데이터 페이지 번호, 오프셋)`로 주소를 찾아 검색
* 물리적으로 재배열 하지 않음
* 인덱스의 구조는 데이터 행과 독립적
* 한 테이블에 `여러 개` 생성 가능
* `검색 속도는 느리지만`, 데이터의 입력/수정/삭제는 빠름

<br>

## 정규화

### 👉 정의
* 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 `무손실 분해` 하는 과정
  * 무손실 분해: 하나의 릴레이션을 분해하고 다시 조인연산을 했을 때 데이터 손실이 없는 것, 분해된 테이블이 표현하는 정보는 분해되기 전의 정보를 모두 포함
* 속성 간의 종속성으로 인한 `이상현상`을 `테이블을 분해`해 해결하는 것
  * 이상현상 (Anomaly): 테이블 내의 데이터가 중복되어 테이블을 조작할 때 발생하는 데이터 불일치

### 👉 목적
* 데이터 `중복 최소화`, 불필요한 데이터 최소화
* `무결성` 유지, `이상 현상` 방지
* 테이블의 구성을 논리적/직관적으로 수정

### 👉 종류
#### 제 1 정규화 (1NF)
* 테이블 컬럼이 `원자 값`을 갖도록 분해
* 모든 필드가 원자 값으로만 되어 있어야 함

#### 제 2 정규화 (2NF) 
##### 함수적 종속
* X -> Y: X = 결정자, Y = 종속자 (Y는 X에 함수적 종속, X/Y는 속성의 부분집합)
* X의 값을 알면 Y를 식별할 수 있고, X의 값에 Y의 값이 달라짐

##### 정의
* 테이블의 모든 컬럼이 `완전 함수 종속`을 만족하도록 분해 
  * 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속
  * 기본키를 구성하는 속성 중 일부에 종속되지 않음
* 테이블에서 기본키가 복합키(키1, 키2)로 묶여있을 때, 두 키 중 하나의 키만으로 다른 컬럼을 결정지을 수 있으면 안됨
  * 기본키의 부분집합이 결정자가 되면 안됨

#### 제 3 정규화 (3NF)
##### 이행적 함수 종속
* X, Y, Z 속성에 대해 X->Y 이고 Y->Z 이면 X->Z

##### 정의
* 기본키가 아닌 모든 속성이 기본키에 `비이행적 종속(직접 종속)`하도록 분해
* 기본키가 아닌 속성이 다른 속성을 결정할 수 없음

#### BCNF (Boyce and Codd Normal Form)
* 모든 결정자가 `후보키`가 되도록 분해
* 함수 종속성 X->Y일 때, 모든 결정자 X가 후보키

<br>

## DB 클러스터링과 리플리케이션의 차이

||DB 클러스터링|리플리케이션|
|:---:|:----------:|:---------:|
|대상|DB 서버를 다중화|DB 서버와 데이터를 같이 다중화|
|구조|수평적 구조<br>(Fail Over)|수직적 구조<br>(Master-Slave)|
|방식|동기 방식으로 동기화|비동기 방식으로 동기화|
|종류|Active - Active, Active - Standby|단순 백업, 부하 분산|
|장점|일관성,<br>1개의 서버가 고장나도 시스템은 계속 사용 가능|시간 지연 거의 없음|
|단점|동기화 시간 소요|일관성 없음,<br>Master 오류시 복구 어려움|
|구조|![clustering](https://user-images.githubusercontent.com/38900338/105463364-4b882300-5cd3-11eb-9837-195b872852e2.JPG)|![replication](https://user-images.githubusercontent.com/38900338/105463420-5f338980-5cd3-11eb-8ea4-fe1bdc962385.JPG)|


<br>

## 커넥션 풀

* `미리 일정 수의 Connection을 만들어 pool에 보관 -> 사용자의 요청이 발생하면 연결을 해주고 연결 종료 시 pool에 다시 반환하여 보관하는 것`
* 사용자의 요청에 따라 Connection 을 생성하다 보면 많은 수의 연결이 발생했을 때 서버에 과부하가 걸리게 되므로 이러한 상황을 방지하기 위해 사용
* 커넥션 풀을 사용하면 커넥션을 생성하고 닫는 시간이 소모되지 않기 때문에 그만큼 어플리케이션의 `실행 속도가 빨라짐`
* 한 번에 생성될 수 있는 커넥션 수를 제어하기 때문에 동시 접속자 수가 몰려도 웹 어플리케이션이 쉽게 다운되지 않음

<br>

## 관계형 데이터베이스(SQL)와 비관계형 데이터베이스(NoSQL)의 차이

|관계형 데이터베이스|비관계형 데이터베이스|
|:----------:|:---------:|
|SQL 사용|다양한 질의어 사용|
|ACID|Eventual Consistency|
|엄격한 스키마 아래 행과 열로 구성된 `테이블`들의 관계로 데이터 저장|스키마가 없거나 느슨한 스키마로 데이터 저장|
|`속성(열)에 맞는 자료형에 따라` 데이터를 삽입|`key-value`, `Document` 구조의 유연한 데이터 삽입 구조를 갖음|
|관계를 맺고 있는 데이터가 자주 변경되거나 테이블 안에서 읽어올 데이터가 불분명한 경우 또는 명확한 스키마가 있는 경우|데이터 구조를 알 수 없거나 테이블 안에서 읽어올 데이터가 분명한 경우 또는 변경 확장이 쉽게 되어야하는 경우|
|데이터의 정렬, 탐색, 분류가 빠름<br>데이터 무결성 보장|대용량 데이터 처리에 효율적<br>관계형 DB보다 쓰기와 읽기 성능이 좋음<br>유연하고 확장성 좋음|
|기존의 스키마 수정 어려움, 빅데이터 처리에 비효율적|크기가 큰 Document에서는 성능 저하|
|`Oracle`, `MySQL`|키-값: `Redis`<br>문서형(JSON, XML): `MongoDB`|

<br>

## Redis와 MongoDB

* Redis는 No SQL 방식을 사용하는 인메모리 데이터베이스로 `Key-Value` 형식으로 데이터를 저장하며 주로 캐쉬로 사용
* MongoDB는 NO SQL 방식을 사용하는 데이터베이스로 JSON같은 구조의 `Document` 형식으로 데이터를 저장하고 문서에 대한 ID를 키로 표현

<br>

## Redis의 데이터 휘발을 막기 위한 방법

* `snapshot` 기능을 통해 디스크에 백업하거나 `AOF(Append Only File)` 기능을 통해 `명령 쿼리를 저장`해두고 서버가 셧다운 되면 재실행
* snapshot: 특정 시점의 백업 및 복구에 유리, 빠르게 복구 가능, 서버가 다운되면 스냅샷 사이에 변경된 데이터 유실
* AOF: 모든 write/update 연산 자체를 모두 log 파일로 기록, 서버가 실행되면 순차적으로 연산을 재실행하여 데이터를 복구, write 속도 빠름, 데이터 유실X, 데이터 사용량이 큼, 서버 restart 시 속도 느림

<br>

## PostgresSQL과 ElasticSearch의 차이점

* PostgresSQL은 관계형 데이터베이스이고 ElasticSearch는 검색 및 분석엔진
* ES는 데이터 모델을 JSON으로 하고 있어 NoSQL처럼 사용할 수 있음

<br>

## [추가] NoSQL(Not Only SQL)
* 관계형 데이터베이스가 아닌 다른 형태
로 데이터를 저장하는 기술
* 특징
  * 반정형(명확한 스키마 없음, 일정 수준의 자유도 허용, NoSQL/JSON 형태의 데이터)/비정형(스키마 없음, 비디오/오디오 등의 멀티미디어 데이터) 데이터에 적합
  * ACID 대신 Eventual Consistency: Consistency를 조금 타협하고 꼭 실제 최신은 아닐 수 있지만 `업데이트가 되기 전까지는` 가지고 있는 최신의 데이터를 반환함을 의미 -> 분산형의 특성상 일관성 유지가 어려움
  * 대용량/분산형 데이터 저장에 유리
  * 특정 도메인의 문제 해결에 좋음: Key-value, Graph 등 자료 형태가 다양해 특정 분야에서 고성능(소셜 네트워크: 인간 관계는 그래프)
  * 데이터를 질의하는 API가 다양
  * 분산형 컴퓨터에 최적화, 확장성 좋음: 머신의 수를 늘리는 `수평적 확장`
  * NoSQL은 SQL보다 제품 지원이 어려움
  * 인력 운영 비용이 더 비쌈: 표준화 부족, 질의 언어 다양
* 종류
  * Column-based: 열 별로 연속적으로 저장, 기존 SQL은 테이블에 행 단위로 순차적으로 저장 -> 레코드의 특정 부분만 수정할 때, 필요한 열의 데이터만 로드하면 되서 IO 작업 감소, 한 열에 들어가는 데이터 형식에 일관성이 있어 DB 내의 한 블록은 동일한 유형의 데이터를 보유 -> 데이터의 유형에 맞는 압축 인코딩 가능, 디스크 공간 절약 및 성능 향상 가능
  * Document-oriented: JSON 객체로 문서(레코드)를 구성, 다양항 구조로 테이블 구성 가능, `MongoDB`
  * Key-Value: 연관 배열을 데이터 모델로 이용, Key는 한 Collection에 한 번만 등장 가능
  * Graph

<br>

## 파티셔닝

### 정의
* `하나의 DB`에서 데이터를 물리적으로 분할하는 것
* 튜닝 기법: 데이터 용량 증가 시의 성능 향상, 관리 용이를 위해 진행

### 장점
* 관리 용이: 큰 테이블을 제거하여 관리가 쉬움
* 읽기/쓰기 성능 향상
* Insert 시에 분리된 파티션으로 분산시켜 경합을 줄임

###  단점
* 조인 비용 증가
* 테이블과 인덱스를 별도로 분리할 수 없고, 함께 분리해야 됨

### 분할 방법
#### 수평 분할 (Horizontal Partitioning)
* 하나의 DB안에 스키마가 같은 데이터를 두 개 이상의 테이블에 분할하여 저장
* 예시
  * 주민 테이블 -> a동 테이블, b동 테이블로 분리
#### 수직 분할 (Vertical) Partitioning)
* 테이블을 열을 기준으로 분리
* 정규화된 테이블을 분리하는 것

<br>

## 샤딩

### 정의

* `여러 DB`에 데이터를 물리적으로 `수평 분할 방식(Horizontal Partitioning)`으로 분산 저장/조회하는 것
* `트래픽 분산` 목적으로 사용: 데이터베이스에 데이터 증가 -> 용량 이슈, CRUD 성능 저하
* 애플리케이션 서버 레벨에서 구현하는 경우가 많았으나 최근에는 플랫폼 차원에서도 제공
  * Hibernate Shards, Spock Proxy(MySQL Proxy 기반), Gizzard(Twitter), Spider(MariaDB 기본 내장)
* 예시
  * 주민 테이블 -> a동 테이블은 A DB, b동 테이블은 B DB에 저장

### 장점
* 쓰기 성능 향상 (읽기 성능 동일)

### 단점
* 두 개 이상의 샤드에서 `JOIN 불가`
* 일관성과 복제에서 불리
* auto increment 등은 샤드 별로 달라질 수 있고, last_insert_id() 값은 유효하지 않음

<br>

## 레플리카

### 정의
* `동일한 데이터를 Master/Slave DB로 나누어 저장`하는 것 (이중화)
* 목적
  * `읽기(Select) 성능을 향상`하기 위한 방법
  * 읽기와 쓰기 DB를 분리하여 성능을 향상시킴
  * Fail Over 방지: 메인 DB에 문제가 생겨도 서브 DB로 해결
