# Network

<br>

## Table of Contents
* [TCP와 UDP의 차이](#tcp와-udp의-차이)
* [TCP 흐름제어](#tcp-흐름제어)
* [TCP 혼잡제어](#tcp-혼잡제어)
* [TCP 3-way Handshake](#tcp-3-way-handshake)
* [TCP 4-way Handshake](#tcp-4-way-handshake)
* [OSI 7계층](#osi-7계층)
* [CDN Contents Delivery Network](#cdn-contents-delivery-network)
* [로드 밸런싱](#로드-밸런싱)
* [CIDR](#cidr)
* [NAT (Network Address Translation)](#nat-network-address-translation)
* [HTTP 특징](#http-특징)
* [HTTP 1, 2, 3의 차이](#http-1-2-3의-차이)
* [HTTP 상태코드](#http-상태코드)
* [HTTP와 HTTPS의 차이](#http와-https의-차이)
* [HTTPS 통신 과정](#https-통신-과정)
* [HSTS (HTTP Strict Transport Security)](#hsts-http-strict-transport-security)
* [웹 브라우저에 URL을 입력했을 때의 수행 과정](#웹-브라우저에-url을-입력했을-때의-수행-과정)
* [쿠키와 세션](#쿠키와-세션)
* [캐시](#캐시)
* [JWT](#jwt)
* [웹 캐시](#웹-캐시)
* [URI, URL, URN](#uro-url-urn)
* [REST](#rest)
* [REST API](#rest-api)
* [REST API 장단점](#rest-api-장단점)
* [RESTful](#restful)
* [HTTP GET 방식과 POST 방식의 차이](#http-get-방식과-post-방식의-차이)
* [HTTP POST 방식과 PUT 방식의 차이](#http-post-방식과-put-방식의-차이)
* [HTTP PATCH 방식과 PUT 방식의 차이](#http-patch-방식과-put-방식의-차이)
* [HTTP 멱등성](#http-멱등성)
* [웹 브라우저에 HTTP 응답이 랜더링되는 과정](#웹-브라우저에-http-응답이-랜더링되는-과정) *

<br>

## TCP와 UDP의 차이

### 👉 TCP
* `신뢰성을 보장하는 연결형 프로토콜`
* `흐름제어, 혼잡제어`를 제공
* 웹 HTTP 통신, 이메일, 파일 전송에서 사용

### 👉 UDP
* `신뢰성을 보장하지 않는 비연결형 프로토콜`
* 흐름제어, 혼잡제어를 제공하지 않음
* 속도 빠르고 연속성이 중요한 서비스(스트리밍)에서 사용
* UDP 자체는 신뢰성을 보장하지 않지만 추가적인 정의를 통해 보장 가능 (HTTP/3에서 QUIC 프로토콜)

<br>

## TCP 흐름제어
* `수신자와 송신자`의 메시지 처리속도 차이를 해결하기 위한 방법
* 수신자와 송신자 세그먼트 간의 TCP Header에 `remain window data`를 통해 남은 버퍼를 알고 흐름을 파악할 수 있음

### 👉 종류
#### Stop and Wait
* 전송한 패킷의 ACK을 수신하면 다음 패킷 전송
#### Sliding Window
* 수신측에서 설정한 윈도우 크기만큼의 패킷을 ACK의 확인 없이 전송, 데이터의 흐름을 동적으로 조절
* `Go Back N`: Cumulative ACK(마지막으로 수신 성공한 패킷의 ACK을 계속 전송), 문제가 된 패킷부터 모두 재전송
* `Selective Repeat`: Individual ACK(수신 성공한 패킷의 개별 ACK 전송), 문제가 된 패킷만 재전송

<br>

## TCP 혼잡제어
* `송신자와 네트워크(라우터)`의 데이터 처리 속도 차이를 해결하기 위한 방법
* 패킷 loss 시의 확인되는 `timeout이나 3개의 duplicate ACK`을 통해서 파악 가능

### 👉 종류
* [참고] CWND: Congestion Window, ACK을 확인하지 않고도 보낼 수 있는 데이터 양 (Window Size)
#### TCP Tahoe
* Slow Start(CWND가 1부터 지수적으로, 2배씩 증가) -> ssthresh -> Congestion Avoidance(CWND가 1씩 증가) -> 3개의 duplicate ACK, Timeout 발생 -> Slow Start부터 반복
#### TCP Reno
* Slow Start(CWND가 1부터 지수적으로, 2배씩 증가) -> ssthresh -> Congestion Avoidance(CWND가 1씩 증가)까지는 동일
* Congestion Avoidance 상황에서 3개의 duplicate ACK 발생 -> CWND를 1/2배로 감소하고 선형적 증가 (TCP Tahoe는 Slow Start로 진입)
* Congestion Avoidance 상황에서 Timeout 발생 -> Slow Start (CWND = 1, CWND가 1부터 2배씩 증가)

<br>

## TCP 3-way Handshake

### 👉 언제 일어나고 어떤 과정인지
* 서버와 클라이언트가 TCP `연결을 성립할 때` 사용
* Client -> Server: 연결을 요청하는 `SYN(n) 전송`
* Server -> Client: 요청을 수락하는 ` ACK(n+1) 전송` + 연결을 요청하는 `SYN(m) 전송`
* Client -> Server: 요청을 수락하는 `ACK(m+1) 전송`

### 👉 필요성
* TCP는 양방향 프로토콜이므로 클라이언트와 서버가 각각 서로에게 패킷을 전송할 수 있다는 것을 확인해야 됨

### 👉 Sequence Number를 난수로 이용하는 이유
* 연결을 맺을 때 사용하는 포트(port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용됨
* 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용할 가능성이 존재함
* 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데, 난수가 아닌 순차적인 number가 전송된다면 이전의 연결로부터 오는 패킷으로 인식할 위험이 있음

<br>

## TCP 4-way Handshake

### 👉 언제 일어나고 어떤 과정인지
* 서버와 클라이언트가 TCP `연결을 종료할 때` 사용
* Client -> Server : 연결을 종료하는 `FIN(n) 전송`
* Server -> Client : 요청을 수락하는 `ACK(n+1) 전송`
* Server -> Client : 연결을 종료하는 `FIN(m) 전송`
* Client -> Server : 요청을 수락하는 `ACK(m+1) 전송`

### 👉 타임아웃은 언제, 왜 일어나는가
* 서버의 지연된 패킷을 수신하기 위해 클라이언트에 `Timeout` 존재 (클라이언트가 서버의 FIN을 수신한 이후)

### 👉 필요성
* 클라이언트가 일방적으로 끊으면 서버는 `연결은 되어 있으나 요청이 없는 상태`로 오해할 수 있음
* 클라이언트는 데이터 전송을 끝냈다고 하더라도 서버는 전송할 것이 남아있을 수 있음

<br>

## OSI 7계층

### 👉 정의
* 네트워크의 통신 과정을 7단계로 나눠 표준화한 것
* ISO(국제표준기구)에서 만듦

### 👉 사용 이유
* 통신 과정을 이해하기 쉬움
* 문제 발생 시 해당 단계의 장비와 SW만 수정하면 됨 -> 해결 용이

### 👉 각 계층의 역할
* Application - Application(7), Presentation(6), Session(5) 계층으로 분리
#### Application(7, Data)
* 사용자에게 `실제 애플리케이션 서비스를 제공`하는 계층
* HTTP, FTP, DNS
#### Presentation(6, Data)
* 애플리케이션의 `데이터 형태와 구조를 변환(번역, 암호화, 압축)`시키는 계층
* 코드 간의 번역을 담당 -> 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어줌
#### Session(5, Data)
* 양 끝단의 응용 프로세스가 `통신을 관리하기 위한 방법`을 제공
  * 동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex)의 통신 등
* 애플리케이션 간의 `TCP/IP 세션을 구축하고 관리하며 종료`시키는 계층
* API, Socket
#### Transport(4, Segment)
* 통신 `양단 간의 신뢰성 있는 통신`을 보장하는 계층
* TCP, UDP
#### Network(3, Packet or Datagram)
* 목적지까지의 경로를 선택하고 `경로에 따라 패킷을 전달(라우팅)`해주는 계층
* IP / 라우터
#### Link(2, Frame)
* 인접한 `피어 간의 신뢰성 있는 통신`을 보장하는 계층
* MAC / 브릿지, 스위치
#### Physical(1, Bit)
* 전기적, 기계적, 기능적인 특성을 이용해서 `통신 케이블로 데이터를 전송`
* 리피터, 케이블, 허브

<br>

## CDN (Contents Delivery Network)

![zz](https://user-images.githubusercontent.com/38900338/135851877-de1980d4-c90f-44c9-89d9-91899775feb6.PNG)

### 👉 정의
* `지리적, 물리적으로 떨어져 있는` 사용자에게 웹 페이지 콘텐츠 `로드 지연을 최소화`하는, 촘촘히 `분산된 서버`로 이루어진 플랫폼 기술

### 👉 사용 시의 이점
* 지리적으로 가까운 캐시 서버가 응답하여 빠른 응답 가능
* Origin 서버에 문제가 생겨도 다른 서버로 대체가 가능해 안전성 증가
* 트래픽 집중 방지 가능

### 👉 과정
* 웹 브라우저를 실행하는 디바이스인 사용자 에이전트는 HTML, 이미지, CSS, JavaScript 파일을 렌더링하는데 필요한 콘텐츠를 요청
* 요청된 서버에 의해 `콘텐츠에 대한 각 요청이 발생하면 최적으로 배치된 CDN 서버에 엔드유저가 매핑`
* CDN 서버는 요청된 파일의 `캐싱`된(사전 저장된) 버전으로 응답

<br>

## 로드 밸런싱
* 로드 밸런서를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산하는 방식
* 로드 밸런서는 물리 장비를 이중화해서 구현하거나 nginx(엔진X)와 같은 웹서버를 이용하여 구현

<br>

## CIDR
* 클래스 없는 도메인 간 라우팅 기법
* 최신의 IP 주소 할당 방법으로 정적이였던 클래스 방식에 비해 IP 주소의 영역을 여러 네트워크 영역으로 나눌 수 있기 때문에 기존방식에 비해 유연

<br>

## NAT (Network Address Translation)
### 👉 정의
* IP 패킷의 TCP/UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 `재기록`하면서 `라우터`를 통해 메시지를 주고 받는 기술
* 외부에 공개된 `공인(Public) IP`와 내부에서 사용하는 `사설(Private) IP`가 다른 경우, 네트워크 전송 시 두 IP주소를 매핑하여 원활히 통신할 수 있게 하는 기술

### 👉 목적
#### 공인 IP 부족 문제 해결
* 한정적인 IP를 다수가 공유해 IP 절약 가능
#### 보안성
* 사설망을 외부로부터 보호할 수 있음
* 외부에서 사설 IP를 알 방법이 없어 내부 내트워크와 호스트를 보호 가능

### 👉 동작 원리
#### 외부로 요청 패킷 전송
* 패켓 헤더 = `소스 IP: 사설 IP`, `목적 IP: 목적지 IP`
* 게이트웨이에서 `소스 IP: 게이트웨이의 공인 IP`, `목적 IP: 목적지 IP` 로 변경 (재기록)
  * NAT 테이블에 맵핑 내역을 저장 (포트도 기록)

### 응답 패킷 받기
* 패켓 헤더 = `소스 IP: 목적지 IP`, `목적 IP: 게이트웨이의 공인 IP`
* 게이트웨이에서 `소스 IP: 목적지 IP`, `목적 IP: 사설 IP` 로 변경 (재기록)
  * NAT 테이블을 참조하여 수정
<br>

## HTTP 특징
* Connectionless: 클라이언트에서 서버에 요청을 보내면 서버는 클라이언트에 응답을 하고 접속을 끊음
* Stateless: HTTP 통신은 요청을 응답하고 접속을 끊기 때문에 클라이언트의 상태정보를 저장하지 않음

<br>

## HTTP 1, 2, 3의 차이
* HTTP 0.9: HTML파일 자체를 응답으로 보냄. 하나의 연결당 1요청 1응답 -> 성능 저하, 서버 부하
* HTTP 1.0: 헤더가 생김. 하나의 연결당 1요청 1응답 -> 성능 저하, 서버 부하
* HTTP 1.1: 연결 당 하나의 요청과 응답을 처리 -> 동시 전송 문제, 속도 성능 이슈가 있음
  * Persistent Connection: 지정한 timeout 동안 커넥션을 닫지 않는 방식
  * 파이프라이닝: 1->2->3 순서대로 각 번호의 요청에 대한 응답을 받아야 처리가 되서, 응답 시간을 줄이고자 등장
    * 하나의 커넥션에서 응답을 기다리지 않고 순차적인 여러 요청을 연속적으로 보내 그 순서에 맞춰 응답을 받는 방식으로 지연 시간을 줄이는 방법
  * HOL(Head of Line) Blocking: 파이프라이닝의 문제점 -> 먼저 받은 요청이 끝나지 않으면 그 뒤에 있는 요청도 처리 불가
  * RTT(Round Trip TIme) 증가
  * 헤더가 큼: 쿠키가 큼. 연속적인 데이터일때, 헤더가 동일하더라도 또 보내게됨.
* HTTP 2: `멀티플렉싱`을 통해 레이턴시를 줄이고, `헤더압축`을 통해 오버헤드를 최소화하며, `서버 푸시 기능`을 지원
  * 메시지 전송 방식 변화: 바이너리 프레이밍 계층 사용 -> 파싱,전송 속도 향성, 오류 발생 가능성 저하
    * 메시지: 다수의 프레임. 요청 응답의 단위
    * 스트림: 양방향 통신을 통해 전달되는 한 개 이상의 메시지
    * 프레임이 여러개가 모여 메시지, 메시지가 여러개가 모여 스트림
  * 한 연결에 여러 메시지를 동시에 처리 가능: 요청들이 프레임 단위로 쪼개짐.(헤더, 데이터 등) -> 메시지 전송과 응답에 순서가 중요하지 않아짐 -> `HOL Blocking 해결`
  * 헤더 압축: 헤더 중복 제거 -> 페이지 로드 시간 감소
  * TCP에서 동작, 스트림
  * Server Push: html 요청이 오면, css와 js 파일이 필요할 것을 예상하고 서버에서 자체적으로 클라이언트에게 보냄
  * 리소스간 우선 순위 설정
* HTTP 3(QUIC): 
  * 헤더 압축(QPACK)
  * 전송 계층 프로토콜
  * 현재 구글 관련 제품 대부분의 기본 프로토콜: UDP기반
  * TCP는 신뢰성을 확보하지만 지연을 줄이기 힘듦. UDP는 공간이 많아 TCP의 지연을 줄이면서 TCP만큼 신뢰성을 보장하도록 개발
  * 전송 속도 향상: 첫 연결 설정에서 필요한 정보와 함께 데이터 전송 -> 연결 성공시 설정을 캐싱하여 다음 연결 때 바로 성립 가능
  * Connection UUID: 고유한 식별자로 서버와 연결 -> 커넥션 재수립 필요X
  * 독립 스트림 -> 향상된 멀티플렉싱

<br>

## HTTP 상태코드  
* 2xx: 성공
* 3xx: 리다이렉션
  * 301(Moved Permanently): 요청한 자원의 URL이 변경됨, 새로운 URL이 응답에 있을 수도 있음
  * 302(Found): 요청한 자원의 URL이 일시적으로 변경됨, 새롭게 변경된 URL이 나중에 만들어질 수도 있어 클라이언트는 동일한 URI로 요청해야 함
* 4xx: 클라이언트 에러
  * 401(Unauthorized): 클라이언트는 요청에 대한 응답을 받기위해 인증이 필요
  * 403(Forbidden): 클라이언트는 자원에 접근할 권리가 없음, 401과 다르게 서버가 클라이언트가 누구인지 알 고 있음
* 5xx: 서버 에러

<br>

## HTTP와 HTTPS의 차이
### 👉 HTTP
* 웹 브라우저와 웹 서버가 통신하기 위한 프로토콜
* 평문 통신이기 때문에 `도청`이 가능하고 `변조`가 가능
* 통신 상대를 특정하지 않기 때문에`위장`이 가능

### 👉 HTTPS (HTTP Secure)
* HTTP에 SSL/TLS 기반의 Secure Socket을 활용한 프로토콜
* 웹 브라우저와 웹 서버가 각각 키를 가지며 `그 키를 통해 암호화/복호화하여 HTTP통신`을 하기 때문에 클라이언트와 서버만이 데이터를 열람 가능

<br>

## 대칭키 암호화
### 👉 정의 
* 하나의 키로 암/복호화를 모두 하는 방식

### 👉 장단점
* 암호화 연산 속도가 빠르기 때문에 효율적인 암호 시스템을 구축할 수 있음
* 키 전달 및 관리에 어려움: 데이터를 보낼 때, 암호키도 함께 전송하는데 암호키 자체는 암호화가 되지 않은 평문으로 분실하거나 타인에게 노출되면 보안에 매우 취약

<br>

## 비대칭키(공개키) 암호화
### 👉 정의 
* 암/복호화를 하는 키를 분리한 방식
* 대칭키 암호화 방식의 키 전달의 취약점을 해결하기 위해 나온 방법
* 비공개키(개인키)는 자신만이 소유하여 사용, 공개키는 타인에게 공개

### 👉 장단점
* 대칭키 암호화 방식의 키 전달 문제를 해결
* 암/복호화를 위해 복잡한 연산을 수행해 속도가 느림

<br>

## HTTPS 통신 과정
* SSL/TLS Handshaking이라고 함

### 👉 참고 사항 1
#### 인증기관 (Certification Authority, CA)
* 인증기관으로부터 공인인증서를 발급받아 서버에 설치해야 HTTPS 통신 가능
* 웹 서비스 제공자는 자신의 공개키와 개인키를 생성, `공개키를 인증기관에 보냄`
* 인증기관은 공개키, 유효기간 등 정보를 포함하여 `인증기관의 개인키로 전자서명한 인증서를 발급`
* 웹 서버는 인증서와 개인키를 가지게 되어 HTTPS 통신을 할 수 있게 됨
* 클라이언트에는 여러 인증기관의 공개키와 인증서가 이미 설치되어 있음
* 웹 서버와 통신 시, 인증기관의 `개인키`로 서명된 인증서를 클라이언트가 받으면 인증기관의 `공개키`로 복호화 가능

### 👉 참고 사항 2
* SSL을 사용하면 `https://` 를 사용하여 웹서버에 접근
* 대칭키: 실제 데이터 암호화 방식
* 공개키: 대칭키를 공유하기 위해 사용

### 👉 과정
* Client Hello: 웹 브라우저가 웹 서버에 접속
* Server Hello: 웹 서버는 인증서를 웹 브라우저에게 전송 -> 인증서: 인증기관의 개인키로 암호화된 `사이트의 정보`와 `공개키`가 있음
* 웹 브라우저는 이미 가지고 있는 인증기관의 `공개키`로 웹 서버에서 받은 인증서를 `복호화` 해서 확인
* 웹 브라우저는 실제 데이터의 암호화에 사용될 `대칭키`를 생성, 인증서에서 꺼낸 웹 서버의 `공개키`로 `암호화` 해서 웹 서버로 전송
* 웹서버는 자신이 가지고 있는 `개인키`로 웹 브라우저가 보내온 `대칭키`를 `복호화` 해서 얻음 ((비대칭키 암호화)
* 해당 대칭키로 데이터를 암호화해서 주고 받음
 
<br>

## HSTS (HTTP Strict Transport Security)
### 👉 정의
*  Web Site에 접속할 때, 강제적으로 `HTTPS Protocol`로만 접속하게 하는 기능
* 브라우저는 HTTPS를 사용해야 하는 웹 사이트의 목록(HSTS List)을 만들고 이것을 사용
* 일정시간 (max-age, HSTS 리스트에 존속하는 시간) 동안 HSTS 응답을 한 웹사이트에 대해서 https 접속을 강제화

### 👉 사용 목적
* SSL Stripping 공격(중간자 공격)을 방지하기 위해 사용
* 사용자가 HTTPS를 지원하는 사이트에 HTTP로 접속 했을 때, 중간자 공격에 의해 HTTP 통신을 하게 되어 공격자에게 정보가 노출되는 것을 방지

<br>

## 웹 브라우저에 URL을 입력했을 때의 수행 과정
### 👉 과정
* 사용자의 PC는 `DHCP 서버`에서 사용자 `자신의 IP 주소`, `가장 가까운 라우터의 IP 주소`, `가장 가까운 DNS서버의 IP 주소`를 받는다.
* `ARP`를 이용하여 IP 주소를 기반으로 가장 가까운 라우터의 MAC 주소를 받는다.
* 가장 가까운 라우터의 MAC 주소와 IP 주소를 사용해 DNS 서버로 쿼리를 전송하고 URL의 IP 주소를 응답받는다.
* TCP Socket을 통해 웹 서버와 `3 way hand shaking`을 하여 연결한다.
* `HTTP Request`가 TCP Socket을 통해 보내지고, 응답으로 웹페이지의 정보가 사용자의 PC에 전달

### 👉 참고 사항
#### 기타 네트워크 프로토콜과 기본 네트워크 주소들
* DHCP: 호스트의 IP 주소 및 TCP/IP 설정을 클라이언트에 자동으로 제공하는 프로토콜
* DNS: IP 주소와 도메인의 매핑 정보를 관리하는 프로토콜
* ARP: IP 주소를 물리적 네트워크 주소로 대응시키기 위해 사용되는 프로토콜
* IP 주소: 컴퓨터 마다 부여된 고유의 주소
* MAC 주소: NIC 카드 마다 부여된 네트워크 장비 고유의 주소

<br>

## 쿠키와 세션
* HTTP 통신에서 Connectionless, Stateless 보완

### 👉 쿠키
* `클라이언트의 로컬(브라우저)`에 저장되는 `키와 값`이 들어있는 작은 텍스트 파일
* 이름, 값, 만료 날짜/시간, 경로 정보 등 저장
* 예시: 자동 로그인, 쇼핑몰의 장바구니, 아이디와 비밀번호 저장

### 👉 쿠키의 동작 과정
* 클라이언트가 서버에 요청
* 서버는 `HTTP 응답 헤더`에 `set-cookie` 속성을 추가하여 응답 -> 클라이언트는 쿠키 저장
* 클라이언트는 이후 서버에 요청할 때 전달받은 쿠키를 자동으로 요청헤더에 추가하여 요청(브라우저가 자동으로 추가)
* 서버에서 쿠키를 참고하여 로직 수행

### 👉 세션
* 일정 시간동안 `같은 브라우저`에서 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 객체로 `서버`에 저장하는 기술
* 예시: 로그인

### 👉 세션의 동작 과정
* 클라이언트가 서버에 요청
* 서버는 세션에 클라이언트에 대한 데이터를 저장하고 `HTTP 응답 헤더`에 `sessionid`를 추가하여 응답
* 클라이언트는 이후 서버에 요청할 때 전달받은 세션 쿠키를 자동으로 요청헤더에 추가하여 요청
* 서버에서 `sessionid`를 참고하여 로직 수행

### 👉 차이점
||쿠키|세션|
|:---:|:---:|:---:|
|저장 위치| 클라이언트 `로컬`에 `작은` 파일로 저장|`서버`에 `제한 없는` 파일로 저장|
|보안|파일로 저장해 탈취와 변조 가능<br> 응답/요청 시에 스니핑 위험이 있음|`sessionid`를 통해 데이터를 구분하여 처리하여 보안이 좋음|
|Life Cycle|브라우저를 종료해도 파일로 남음|브라우저 종료 시, 세션 삭제|
|속도|파일에서 읽어 빠름|요청마다 서버에서 처리해 느림|

<br>

## 캐시
* 이미지나 css, js파일 등을` 브라우저나 서버 앞 단에 저장`해놓고 사용하는 것
* 같은 자원을 로드(load)해야할 때, 해당 자원을 다시 불러오지 않고 캐시되어 있는 자원을 써서 클라이언트 자원을 절약
* 캐시에 있는 것을 재사용하기 때문에 경우에 따라 변경된 자원을 참조할 수 없는 경우가 생김

<br>

## JWT *
* JSON Web Token
* `Json` 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Token
* Header, Payload, Signature로 구성
* 세션은 사용자의 수 만큼 서버 메모리를 차지하기 때문에, 최근에는 세션의 문제를 보완한 토큰 기반의 인증방식을 사용하는 추세

<br>

## 웹 서버와 웹 애플리케이션 서버의 차이점
### 👉 웹 서버
* Http 프로토콜을 기반으로, 클라이언트의 요청을 처리하는 서버
* `정적 컨텐츠`만 처리하는 고성능 서버

### 👉 웹 애플리케이션 서버
* 보통 웹서버 뒤에서 DB 조회 및 다양한 로직 처리 요구 시, `동적 컨텐츠`를 처리하는 서버

<br>

## 웹 캐시
* 대부분의 브라우저에서는 `HTTP 헤더`에 캐시 구현이 포함되어 있어서 웹 캐시를 구현
* 응답 헤더의 `Last-Modified`, Etag, Expires, Cache-Control 항목 등과 같은 여러 부분의 여러 개의 태그를 통해서 캐싱
* `Cache-Control`: HTTP 헤더를 통해 캐싱 정책을 정의할 수 있다.
  * `no-cache`: 캐시를 사용하기 전에 서버에 캐시를 사용해도 되는지 재검증 요청
  * `no-store`: 캐싱하지 않음
* 브라우저는 최초 응답 시 받은 `Last-Modified` 값을 If-Modified-Since라는 헤더에 포함 시켜 페이지를 요청 ->서버는 요청 파일의 수정 시간을 If-Modified-Since값과 비교하여 동일하다면 304 Not Modified로 응답하고 다르다면200 OK -> 브라우저는 응답 코드가 304인 경우 캐쉬에서 페이지를 로드하고 200이라면 새로 다운받은 후 Last-Modified값을 갱신
* 브라우저는 최초 응답 시 받은 `Etag` 값을 If-None-Match라는 헤더에 포함 시켜 페이지를 요청 -> 서버는 요청 파일의 Etag 값을 If-None-Match 값과 비교하여 동일하다면 304 Not Modified로 응답하고 다르다면 200 OK와 함께 새로운 Etag값을 응답 헤더에 전송 -> 브라우저는 응답 코드가 304인 경우 캐쉬에서 페이지를 로드하고 200이라면 새로 다운받은 후 Etag값을 갱신
* 브라우저는 최초 응답 시 받은 `Expires` 시간을 비교하여 기간 내라면 서버를 거치지 않고 바로 캐쉬에서 페이지를 로드

<br>

## URI, URL, URN
### (1) URI(Uniform Resource Identifier)
* 자원을 고유하게 식별하고 위치를 지정하는 통합 자원 식별자
* URL, URN 두 가지 형태 존재
* 인터넷 프로토콜을 명시함
* 예시: http://www.naver.com
### (2) URL(Uniform Resource Location)
* 특정 서버의 한 리소스에 대한 구체적인 위치
* 자원의 위치와 접근 방법을 분명히 알려줌
* 예시: http://test.com/test/test.pdf 는 test.com서버에서 test폴더안의 test.pdf 파일을 요청
### (3) URN(Uniform Resource Name)
* 자원의 위치와 독립적인 이름
* URL이 변경되면 기존의 객체를 찾을 수 없다는 URL의 한계를 극복하기 위해 사용
* 예시: urn:2.19.222

<br>

## REST 
* 자원을 `이름`으로 구분하여 자원의 상태를 주고 받는 것
* `HTTP, WWW에서 웹에 존재하는 모든 자원에 고유한 URI를 부여`해 활용하는 것으로, 자원을 정의하고 자원에 대한 주소를 지정하는 방법론
* `HTTP URI`를 통해 자원을 명시하고 `HTTP Method(POST, GET, PUT, DELETE)`를 통해 해당 자원에 대한 `CRUD` 연산을 적용

<br>

## REST API
* `REST API`는 `REST 기반의 규칙들을 지켜서 설계된 API`
* 기본 설계 원칙1. `/`를 계층관계를 나타내는데 사용하되 마지막 문자에 `/`를 포함하지 않음
* 기본 설계 원칙2. 자원에 대한 정보는 명사로 표현하고 자원에 대한 `행위는 HTTP 메소드`로 표현
* 기본 설계 원칙3. 소문자와 `-(하이픈)`를 사용
  * 대소문자에 따라 다른 자원으로 인식될 수 있음
  * 밑줄(_)은 사용하지 않음
* 기본 설계 원칙4. 브라우저는 form-data 형식의 submit 으로 보내고 서버에서는 json 형태로 보내는 식의 분리보다는 둘 다 form-data 형식으로 보내든 하나로 통일

<br>

## REST API 장단점
### 👉 장점
* HTTP를 사용하므로 웹 인프라를 그대로 이용 가능 (별도의 인프라 필요 없음)
* HTTP 표준 프로토콜을 따르는 모든 플랫폼에서 사용 가능
* MSA에 적합하여 재사용에서 이점이 존재

### 👉 단점
* HTTP를 사용하므로 HTTP 통신 모델에 제약적
* 명확한 표준이 존재하지 않아 사람마다 다르게 해석하고 사용할 수 있음

<br>

## RESTful
* `REST 원리를 따르는 시스템`을 나타내기 위해 사용하는 용어
* RESTful한 API를 구현하는 목적은 성능 향상이 아니라 `일관적인 컨벤션`을 통한 API의 이해도 및 호환성을 높이는 것

<br>

## HTTP GET 방식과 POST 방식의 차이

|GET|POST|
|:--:|:--:|
|데이터를 `조회`하는 메소드|데이터를 `생성`하는 메소드|
|`URL의 파라미터`로 이름과 데이터가 쌍으로 명시되어 전달|`HTTP Request Message의 Body` 부분에 데이터가 담겨있음|
|`URL의 길이는 제한적`이기 때문에 많은 양의 데이터를 전송할 수 없음|`HTTP RequestMessage의 Body`에 데이터가 담겨있어 제한이 없음|
|서버로 데이터를 전송할 수 있음|서버로 데이터를 전송할 수 있음|

<br>

## HTTP POST 방식과 PUT 방식의 차이

|POST|PUT|
|:--:|:--:|
|데이터를 `생성`하는 메소드|데이터를 `생성 및 수정`하는 메소드|
|request message에 포함된 엔티티를 이용해 새로운 자원을 생성|자원의 `식별자`를 이미 알고있는 상태 -> request message와 함께 넘어온 식별자의 자원을 만드는 것|
|멱등X|멱등|

### 👉 POST 요청 예시

* 아래 요청을 2번 반복할 경우
```
POST /new
{
  "name": "고양이",
  "grade": 1
}
```

* 식별자가 다른 2개의 자원 생성
```
{ "id": 1, "name": "고양이", "grade": 1 }
{ "id": 2, "name": "고양이", "grade": 1 }
```

### 👉 PUT 요청 예시

* 아래 요청을 2번 이상 반복할 경우
* POST와 다르게 요청에 식별자 포함
```
PUT /new/3
{
  "name": "강아지",
  "grade": 2
}
```
* 처음에는 자원이 없기 때문에 생성되고, 그 이후는 생성되지 않음
```
{ "id": 3, "name": "강아지", "grade": 2 }
```

<br>

## HTTP PATCH 방식과 PUT 방식의 차이

|PATCH|PUT|
|:--:|:--:|
| 자원의 `일부분을 수정`할 경우|자원 `전체를 수정/생성`할 경우|

* PUT
  * 요청을 보내지 않은 필드는 DEFAULT 값으로 변경되므로 요청 시에 모든 필드를 전송해야 됨

<br>

## HTTP 멱등성

* 같은 요청을 반복하는 경우, 모든 요청에 따른 `서버의 상태가 같아야` 함
* 안전한 메소드(GET, 서버의 상태 변경X)는 서버의 상태를 변경시키지 않음
* 멱등한 메소드(PUT, DELETE, GET)는 서버의 상태를 변경시킬 수도 있고 아닐 수도 있음
* POST는 멱등이 아니면서 안전하지도 않음

<br>

## 웹 브라우저에 HTTP 응답이 랜더링되는 과정 *
  *