# 그리디
- 탐욕적으로 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미한다.
- 정당성 분석이 중요하다.
  - 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토한다.
- 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많다.
- 코딩 테스트에서의 대부분의 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제


### 거스름돈 : 정당성 분석
```
가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이면 작은 단위의 동전들을 종합해 다른 해가 나올 수 없다.
만약에 800원을 거슬러 주어야 하는데 화폐 단위가 500원,400원,100원 이라면,
500원 1개 100원 3개가 우리의 알고리즘이였지만, 정답은 400원 2개가 최소 동전 갯수이다.
```

### 1이 될 때까지 : 문제 설명
어떠한 수 N이 1 이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 단, 두번째 연산은
N이 K로 나누어 떨어질 때만 선택할 수 있습니다.
1. N에서 1을 뺀다.
2. N을 K로 나눈다.
예를 들어 N이 17, K가 4라고 가정. 이때 1번의 과정을 한 번 수행하면 N은 16이 됩니다. 이후에
2번의 과정을 두 번 수행하면 N은 1이 된다. 결과적으로 이 경우 전체 과정을 실행한 횟수는 3이다.
이는 N을 1로 만드는 최소 횟수다. 이 최소 횟수를 구하는 프로그램을 작성해라.

```
- 최대한 많이 나누기를 수행하라.
- N의 값을 줄일 때 2 이상의 수로 나누는 작업이 1을 빼는 작업보다 수를 훨씬 많이 줄인다.
- 이게 과연 최적의 해를 항상 보장할까?
- yes. 계속 나눈다면 기하급수적으로 빠르게 줄인다.
- K가 2 이상이기만 하면, K로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄인다.
```
```python
n,k=map(int,input().split())
result=0
while True:
  # N이 Kㄹ 나누어 떨어지는 수가 될 때까지 빼기
  target=(n//k)*k
  result+=n-target
  n=target
  # N이 K보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출
  if n<k:
    break
  # K로 나누기
  result+=1
  n//=k
# 마지막으로 남은 수에 대하여 1씩 빼기
result+=n-1
print(result)
```

### 곱하기 혹은 더하기
각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x' 혹은 '+' 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하세요. 단, +보다 x를 먼저 계산하는 일반적ㅇ니 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정합니다.
```
대부분의 경우 곱하기가 더 값을 크게한다.
다만, 두 수중에서 하나라도 0 혹은 1인 경우 곱하기보다 더하기를 수행하는 것이 효율적이다.
두 수에 대한 연산을 수행할 때, 두 수 중에서 하나라도 1 이하인 경우에는 더하며, 두 수가 모두
2이상인 경우에는 곱하면 정답
```

```python
# 내 풀이
s='567'
sum=int(s[0])
for i in range(1,len(s)):
  if s[i-1]=='0' or s[i-1]=='1':
    sum+=int(s[i])
  else:
    sum*=int(s[i])
print(sum)

# 예시
data=input()
result=int(data[0])
for i in range(1,len(data)):
  num=int(data[i])
  if num<=1 or result<=1:
    result+=num
  else:
    result*=num
```

### 모험가 길드
한 마을에 모험가가 N명 있습니다. 모험가 길드에서는 N명의 모험가를 대상으로 '공포도'를 측정했는데, '공포도'가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어진다. 모험가 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했습니다. 동빈이는 최대 몇 개의 모험가 그룹을 만들 수 있는지 궁금합니다. N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최댓값을 구하는 프로그램을 작성하세요. 

```
오름차순으로 정렬한다. 앞에서부터 공포도를 하나씩 확인하며 '현재 그룹에 포함된 모험가의 수'가 
'현재 확인하고 있는 공포도'보다 크거나 같다면 이를 그룹으로 설정
오름차순으로 정렬되어 있다는 점에서, 항상 최소한의 모험가의 수만 포함하여 그룹을 결성하게 된다.
모두 데리고 갈 필요가 없다!!
```
```python
n=int(input())
data=list(map(int,input().split()))
data.sort()

result=0 # 총 그룹 수
count=0 # 현재 그룹에 포함된 모험가의 수
for i in data:
  count+=1
  if count>=i:
    result+=1
    count=0
print(result)
```

# 구현
- 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정이다.
- 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제
  - 알고리즘은 간단한데 코드가 지나칠 만큼 길어짐
  - 실수 연산을 다루고, 특정 소수점 자리까지 출력
  - 문자열을 특정한 기준에 따라서 끊어 처리해야함
  - 적절한 라이브러리를 찾아서 사용
- 일반적으로 알고리즘 문제에서의 2차원 공간은 행렬의 의미로 사용
- 시뮬레이션 및 완전 탐색 문제에서는 2차원 공간에서의 방향 벡터가 자주 활용
```python
# 북 서 남 동
dx=[0,-1,0,1]
dy=[1,0,-1,0]
x,y=2,2
for i in range(4):
  nx=x+dx[i]
  ny=y+dy[i]
```

## 상하좌우
여행가 A는 N x N 크기의 정사각형 공간 위에 서 있습니다. 이 공간은 1 x 1 크기의 정사각형으로 나누어져 있습니다. 가장 왼쪽 위 좌표는 (1,1)이며, 가장 오른쪽 아래 좌표는 (N,N)에 해당합니다. 여행가 A는 상,하,좌,우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1,1)입니다. 우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여 있습니다.
계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L,R,U,D 중 하나의 문자가 반복적으로 적혀 있습니다. 각 문자의 의미는 다음과 같습니다.
- L : 왼쪽으로 한 칸 이동
- R : 오른쪽으로 한 칸 이동
- U : 위로 한 칸 이동
- D : 아래로 한 칸 이동
이때 여행가 A가 N x N 크기의 정사각형 공간을 벗어나는 움직임은 무시된다. 예를 들어 (1,1)의 위치에서 L 혹은 U를 만나면 무시된다.

```python
# 내 코드
n=int(input())
data=list(map(str,input().split()))
dx=[0,-1,0,1]
dy=[1,0,-1,0]
x,y=1,1
for i in range(len(data)):
  if data[i]=='R':
    if x<n:
      x=x+dx[3]
      y=y+dy[3]
    else:
      continue
  elif data[i]=='L':
    if x>1:
      x=x+dx[1]
      y=y+dy[1]
    else:
      continue
  elif data[i]=='U':
    if y>1:
      x=x+dx[2]
      y=y+dy[2]
    else:
      continue
  else:
    if y<n:
      x=x+dx[0]
      y=y+dy[0]
    else:
      continue
print(y,x)

# 풀이
n= int(input())
x,y=1,1
plans=input().split()
dx=[0,0,-1,1]
dy=[-1,1,0,0]
move_types=['L','R','U','D']
for plan in plans:
  for i in range(len(move_types)):
    if plan == move_types[i]:
      nx=x+dx[i]
      ny=y+dy[i]
  if nx<1 or ny<1 or nx>n or ny>n:
    continue
  x,y=nx,ny
print(x,y)
```

## 시각
정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성해라. 예를 들어 1을 입력했을 때 다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각입니다.
- 00시 00분 03초
- 00시 13분 30초
반면에 다음은 3이 하나도 포함되어 있지 않으므로 세면 안되는 시각입니다.
- 00시 02분 55초
- 01시 27분 45초

```python
# 풀이
n=int(input())
count=0
for i in range(n+1):
  for j in range(60):
    for z in range(60):
      if '3'in str(i)+str(j)+str(z):
        count+=1
print(count)
```
## 왕실의 나이트
행복 왕국의 왕실 정원은 체스판과 같은 8 x 8 좌표 평면입니다. 왕실 정원의 특정한 한 칸에 나이트가 서있습니다. 나이트는 매우 충성스러운 신하로서 매일 무술을 연마합니다.
나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없습니다.
나이트는 특정 위치에서 다음과 같은 2가지 경우로 이동할 수 있습니다.
- 수평으로 두 이동한 뒤에 수직으로 한 칸 이동하기
- 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기
이처럼 8 x 8 좌표 평면상에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하세요. 왕실의 정원에서 행 위치를 표현할 때는 1부터 8로 표현하며, 열 위치를 표현할 때는 a부터 h로 표현합니다.

```python
string=input()
row=int(string[1])
column=int(ord(string[0])-ord('a'))+1
steps=[(-2,-1),(-2,1),(2,-1),(2,1),
(1,-2),(1,2),(-1,-2),(-1,2)]
result=0
for step in steps:
  nrow=row+step[0]
  ncol=column+step[1]
  if nrow>=1 and nrow<=8 and ncol>=1 and ncol<=8:
    result+=1
print(result)
```

## 문자열 재정렬
알파벳 대문자와 숫자(0~9)로만 구성된 문자열이 입력으로 주어집니다. 이때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에, 그 뒤에 모든 숫자를 더한 값을 이어서 출력합니다.
- 예를 들어 K1KA5CB7이라는 값이 들어오면 ABCKK13을 출력합니다.

```python
# 내 풀이

string=input()
s=""
sum=0
for num in string:
  if ord(num)>=ord('A') and ord(num)<=ord('Z'):
    s+=num
  else:
    sum+=int(num)
s=''.join(sorted(s))
print(s+str(sum))

# 풀이
data=input()
result=[]
value=0

for x in data:
  if x.isalpha():
    result.append(x)
  else:
    value+=int(x)
result.sort()
if value!=0:
  result.append(str(value))
# 리스트를 문자열로 변환하여 출력
print(''.join(result))
```




