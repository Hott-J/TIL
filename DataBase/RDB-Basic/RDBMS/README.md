# RDBMS?

- 테이블 속성

  - 열 : 컬럼, 필드, 속성
    - 컬럼마다 데이터형 준다.
  - 행 : 튜플, 레코드
    - 열과 행으로 이루어져있으므로 2차원이고, 이게 관계형 데이터베이스

- 주 식별자(Primary Key)

  - 1 홍길동 서울시 34
  - 2 김홍도 경기도 24
  - 3 황진이 부산시 27
    - 1이 PK
    - 하나의 레코드를 고유하게 구분할 수 있는 것으로 하나의 컬럼 또는 여러개의 컬럼이 모여 PK를 구성
    - NotNull & Unique
      - 주 식별자
      - NotNull을 무조건 만족해야 주 식별자다.
    - 후보 식별자
      - null을 인정
      - 식별자는 무조건 unique
      - 핸드폰의 경우 unique지만 없을 수도 있으므로 null이 가능.
    - 테이블 등록시 명시해주어야함
    - PK가 없다면 중복된 값이 있을 수 있으므로, 데이터를 삭제하거나 수정할 때 중복된 갑을 삭제하거나 수정할 수 있으므로 큰일난다.

- 키

  - 하나의 테이블에서 각 레코드를 고유하게 식별할 수 있는 컬럼 또는 컬럼의 조합
  - 테이블 디자인 시 키를 정하고 테이블을 데이터베이스에 만들 때 명시적으로 키를 선언
  - 키는 키에 대응하는 인덱스 테이블이 생성됨
    - 인덱스 테이블은 키 값에 의해서 정렬되어 있음.
      - 정렬되어있으므로 빨리 찾을 수 있음.
  - 결정자
    - PK
  - 나머지는 종속자
  - 우리가 부여한 고객번호가 PK가 되면 좋다.
    - 우리가 그 로직을 갖고 있으므로.
  - 관계형데이터베이스가 되기 위해선 반드시 PK가 포함되어야한다.

- 데이터 타입

  - 정수
    - Bit
    - Int
    - Smallint
    - Tinyint (0~255)
    - Bigint
  - 실수
    - Float(4,8)
    - Real
    - decimal(4-16)
      - numeric(4-16)
  - 문자
    - char
      - char(10) : String. 10자리. 2개만 입력 -> 8개 빈공간 남음
    - Varchar
      - 가변길이 char. Varchar(50)이 기본값.
        - 50이 맥시멈이지만 2글자만 써도 2개만 할당.
    - Text
      - Varchar의 응용. Varchar(max)와 동일

- 유니코드

  - Nchar
  - nvarchar
  - Ntext

- 날짜, 시간, 화폐

  - 날짜와 시간
    - datetime
    - smalldatetime
  - 화폐 (쓰지말것. 오류가 난다. decimal을 쓰자!)
    - money
    - smallmoney

- PK 설계

  - 유일 + NotNull
  - 후보 식별자가 없는 경우 임의의 식별자를 만들어 부여한다.(인조 식별자)
  - PK의 데이터 타입 결정

    - 레코드의 발생 가능한 최대 수를 예측
      - 한달에 12만개 판다.
        - int는 21억까지 되니 여유로움
        - (년도,월,seq번호) 를 PK로 잡으면 됨.
          - 년도를 19,20 과 같이 2자리로 잡으면 y2k 문제발생하지만 100년은 보장함.
    - 중학교, 고등학교의 pk
      - 500명이면 1~500 번호로 부여.
        - smallint
    - 크기가 정해져있는건 정하기 편하지만, 계속 데이터가 쌓여 크기가 계속 커지는 건 정하기 어렵다.

  - 고려사항
    - 발생 가능한 최대 레코드 수를 커버할 수 있는 데이터 타입을 선정
    - pk에는 어떤 의미도 부여하지 않는다. 담백하게 notnull & unique만 보장하면 된다.
    - pk 를 직접 쿼리문에 파라미터로 주면, 동시에 똑같은 pk 값을 요청하면 pk 중복으로 오류가 발생한다.
      - pk는 자동으로 증가하는 방식으로 설정해줘야한다.
      - pk 경쟁을 없애야한다.
    - 만약 pk 데이터타입이 char라면...?
      - 자동증가가 안됨.
      - 자릿수를 정렬해서 일목요연하게 해줌.
      - int를 써도 정렬되서 나온다.
      - 경쟁이 없게끔 int로 해서 자동증가를 적용하자.

# 관계

## 1 : M 관계

- 부모와 자식. 한쪽이 관계를 맺은 쪽의 여러 객체를 갖는 것을 의미하며, 가장 흔하게 나타나는 매우 일반적인 형태
  - 누구의 자식이냐? 부모의 pk 값이 자식 테이블의 컬럼에 나타남으로서 관계가 맺어진다. 부모가 없는 자식은 허용이 안된다. 이는 garbage data가 된다.
    - garbage data는 outer join하면 다 나온다. count가 된다. 그리고 join을 해봐야 garbage인지 알기 때문에 오류가 난다.
  - 부모 - 자식 - 손자 : 각각은 관계가 맺어져도 부모-손자의 관계는 아무 관계없다.
  - 부모의 pk값이 자식 테이블에게는 외래키(fk)가 된다. foreign key. 외부에 진짜 pk가 있다.(외부: 부모 테이블). fk는 중복으로 나타날 수 있다. fk는 부모 테이블에 반드시 pk로 존재해야한다.
  - 부모는 여러명의 자식을 낳을 수 있고 안낳을 수도 있다. 자식은 부모가 단 하나로 정해져있다.
  - 트리 구조는 전부 1:M
    - 디렉토리
  - 그림에서 오리발이 있는쪽이 M (자식), 없는쪽이 1 (부모)
  - ERD (entity relation diagram)
  - 자식이 있으면 부모를 삭제할 수 없다. 자식이 없어야 부모가 삭제 가능하다.
- pk를 튜플로 여러개 속성 이상으로 가져온다면, fk가 변경시 자식 테이블의 pk는 초기화된다. 1학년 1반 / 1학년 2반 / 2학년 3반 이 아니라
  2학년 1반으로, 3반 -> 1반으로 초기화

- 1 : M 재귀적 관계
  - 분류 코드
  - Directory
  - 내 안에 PK 와 FK 둘다 있다.

## M : N 관계 (비지니스 관계)

- 쌍방 입장에서 둘다 1 : M 일때를 말함
  - 사실 얘네는 둘이 관계가 없는데 무리하게 넣은 것.
  - 비지니스 로직이 있어야 둘이 관계를 갖게 됨.
  - 쌍방 PK가 중복이 발생하므로 관계형 데이터베이스로 안된다.
- 해결하기 위해 또 하나의 테이블이 필요
  - 동사 테이블
  - 날짜 컬럼이 꼭 필요함.
  - 학생이 과목을 언제 수강한다.
  - 잘 안 변경되는 학생, 과목 같은 테이블은 마스터라고 한다.
    - 마스터끼리 부자 지간인지 확인해야한다.
    - 아니라면 볼 것 없이 M : N 이라 하면 된다.
  - 동사 테이블도 pk가 있으므로 얘도 다른 테이블과 관계를 가질 수 있다.
  - 학생ID + 과목ID : 두가지를 합쳐 pk 로 할 수 있다.
    - A학생이 1번과목을 두번 수강신청 불가능
  - 버스는 좌석을 여러개 갖고 있다. (has 문장 성립 : 1 : M)
  - 고객이 상품을 여러개 갖고 있다. (사고 갖는다. 문장 성립x : M : N)
- 비지니스 로직에 따라 두번 수강신청 불가능 / 두번 구매 가능. 이런식으로 중복을 허용할지 말지 로직을 짜야한다.
  - 중복 허용해야하면 pk 독립적, 중복 허용하지 않아야 하면 튜플로 pk 구성
- 하나의 테이블은 하나의 객체를 모델링해야한다.
- Pk 가 너무 많아지면 얘를 부르기가 힘드므로 대체키를 설정해준다.

## 1 : 1 관계

- 신랑 : 신부 관계
  - 신랑쪽에 신부 FK, 신부쪽에 신랑 FK 존재
  - 각각의 테이블이 합쳐짐. 근원은 하나의 테이블.
  - 서로가 서로를 지우지 못함.
    - 서로가 pk 역할을 하므로, 나를 지우니까 나는 누군가에게 부모이므로 부모가 사라지는건 안되서 삭제가 안된다.
    - ReadOnly
    - 재혼은 가능. update 가능. 이혼은 안됨.
  - 두 테이블을 합치면 pk가 두개가 합쳐지는 꼴이므로 안됨.
    - 1. 새로운 신랑신부가 합쳐진 신랑신부id를 새로 테이블을 만들어야한다. 부부 테이블 만든다. (하나의 테이블)
    - 2. 두 테이블 각각 pk 가 fk가 되게끔 테이블을 생성한다. 두 테이블을 조인하면 부부 테이블과 똑같이 된다. (두개의 테이블 join)
    - 두번째 방법이 신랑과 신부 각각이 비지니스 로직을 처리할 수 있으므로 훨씬 확장성이 좋다. 만약 하나의 테이블로 구성한다면, 신랑의 비지니스인데 신부쪽도 같이 테이블에 만들어지므로 합리적이지 못하다.
  - 개념적으로는 하나, 물리적으로는 두 개라고 이해하면 된다.
  - 철정보 -> 건정보 -> 건정보1/건정보2/건정보3
    - 건정보1 : 부서명,생성날짜
    - 건정보2 : 입출국대장,외국인Id,외국인명,출국일
    - 건정보3 : 날짜, 적용, 입금금액, 출금금액, 잔액
    - 이 세개의 건정보를 하나의 테이블로 만드는게 좋을까? : X
      - 건정보가 엄청많으면 너무 비효율적.
    - 건정보의 공통점을 생각한다.
      - 제목,생산기관,보존연한과 같이 공통분모를 추려 건정보공통 테이블 수정
      - 건정보 공통테이블과 건정보1/2/3 테이블을 1:1로 연결
      - 건정보 공통과 건정보1/2/3은 서로 부부관계. 건정보1,2,3 끼리도 부부
      - 공통 테이블에 테이블명을 추가해서 찾고 싶은 건정보1/2/3 중에 하나를 택해서 (ex) 회계정보테이블) join하게끔 한다.

# 정규화

## 데이터 이상 현상

참고 링크 : https://yaboong.github.io/database/2018/03/09/database-anomaly-and-functional-dependency/

## 제 1 정규화

- 모든 속성은 반드시 하나의 값을 가져야 한다
  - 다가속성 위배
- 값이라는 것은 원자성을 가져야함. 더 이상 쪼갤 수 없는 하나의 값만을 가져야함. -복합속성 위배

- 1 정규화 대상
  - 다가 속성이 사용된 릴레이션
    - 속성 여러개
  - 복합 속성이 사용된 릴레이션
    - 고객명 : 홍길동 -> 홍 + 길동 (고객성 + 고객이름)
    - 주민번호 : 앞의 생년월일 + 뒷자리 고유숫자
      - 생년 + 월 + 일 + 남여구분 + 고유숫자
  - 유사한 속성이 반복된 릴레이션
  - 중첩 릴레이션
  - 동일 속성이 여러 릴레이션에 사용된 경우

## 제 2 정규화

- 두 개 이상으로 구성된 PK에서 발생
- R의 모든 속성이 후보 식별자 전체에 종속
- 일반 컬럼들은 후보 식별자 속성에 완전 함수 종속돼야 한다
- 일반 속성 중에서 후보 식별자 전체에 종속적이지 않은 속성을 찾아 기본 엔티티에서 제거하고, 그 속성의 결정자를 주 식별자로 하는 새로운 상위 엔티티를 생성
- 왕과 왕비가 pk. 왕비가 자기만의 따로 사조직을 운영(반란)

## 제 3 정규화

- 식별자가 아닌 일반 속성 간에는 종속성이 존재하지 않는다
- 3 정규형의 대상이 되는 속성을 이행 종속 속성이라고 함
- 일반 속성간의 종속 관계를 분해하는 것
- 지방 호족들의 반란

## BC 정규형

- 릴레이션에 존재하는 종속자는 후보 식별자가 아니어야 한다

## 역 정규화

- 시스템 성능 향상을 위한 중복 강제로 만듦
  - 대부분 JOIN 시 발생되는 엄청난 계산량을 해결하기 위해 사용
  - 참조 무결성은 보장되어야함
  - select (select count _ a from table),(select count _ b from table) 과 같으면 너무 많이 세야하므로 과부화 걸릴 수 있다
